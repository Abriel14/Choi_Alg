#include <stdio.h>
#include <vector>
#include <string>
#include <iostream>
#include <thread>
#include <algorithm>
#include "ch_funct.cpp"
#include "Z2_polynoms.cpp"

//FGB module
#define LIBMODE 1
#define CALL_FGB_DO_NOT_DEFINE
#include "call_FGb/nv/maple/C/call_fgb.h"
#include "call_FGb/nv/int/gmp.h"
#define FGb_MAXI_BASE 100000



using namespace std;

vector<Z2_polynom> find_polynoms(vector<vector<int>>,vector<vector<int>>,vector<vector<int>>,vector<vector<int>>);

vector<Z2_polynom> compute_GB(vector<Z2_polynom>);

vector<Z2_polynom> find_polynoms(vector<vector<int>> lambda_funct,vector<vector<int>> list_max_faces,vector<vector<int>> list_min_non_faces,vector<vector<int>> indexed_pentagon){
    for(auto v:lambda_funct){
        print_vect(v);
    }
    
    int n = lambda_funct[0].size();
    int m = lambda_funct.size();
    vector<int> ref_max_face(list_max_faces[0]);
    vector<int> compl_ref_max_face {indexed_pentagon[0][0], indexed_pentagon[1][0],indexed_pentagon[3][0]};
    vector<vector<int>> monom_X {{1,0,0}};
    vector<vector<int>> monom_Y {{0,1,0}};
    vector<vector<int>> monom_Z {{0,0,1}};
    Z2_polynom X(3,monom_X);
    Z2_polynom Y(3,monom_Y);
    Z2_polynom Z(3,monom_Z);

    vector<Z2_polynom> reference_variables;
    
    for(int k=0;k<m;k++){
        reference_variables.push_back(X);
    }
    reference_variables[compl_ref_max_face[0]] = X;
    reference_variables[compl_ref_max_face[1]] = Y;
    reference_variables[compl_ref_max_face[2]] = Z;

    for(int k=0;k<n;k++){
        Z2_polynom P_k(3);
        if(lambda_funct[compl_ref_max_face[0]][k]==1){
            P_k = P_k + X;
        }
        if(lambda_funct[compl_ref_max_face[1]][k]==1){
            P_k = P_k + Y;
        }
        if(lambda_funct[compl_ref_max_face[2]][k]==1){
            P_k = P_k + Z;
        }
        reference_variables[ref_max_face[k]] = P_k;
    }

    vector<Z2_polynom> I;

    vector<vector<int>> const_monom {{0,0,0}};

    for (auto min_non_face: list_min_non_faces){
        Z2_polynom P(3,const_monom);
        for(auto k:min_non_face){
            P = P * reference_variables[k]; 
        }
        I.push_back(P);
    }
    return(I);
}


vector<Z2_polynom> compute_GB(vector<Z2_polynom> I){
    Dpol_INT input_basis[FGb_MAXI_BASE];
    Dpol_INT output_basis[FGb_MAXI_BASE];
    Dpol_INT prev;
    double t0;
    I32 m=0;
    const int nb_vars=3;
    char* vars[3]={"x","y","z"}; /* name of the variables (can be anything) */

    FGB(saveptr)(); /* First thing to do : GMP origmal memory allocators are saved */
    init_FGb_Modp(2); /* init FGb for modular computations */
    /* We compute in GF(2)[x,y,z] */

    FGB(PowerSet)(2,1,vars);  /* Define the monomial ordering: DRL(k1,k2) where
			       k1 is the size of the 1st block of variables
			       k2 is the size of the 2nd block of variables
			       and vars is the list of variables
			    */
    threads_FGb(8);
    /* Exporting polynomials to FGB*/
    for(auto P:I){
        int k = P.monoms.size();
        // Create the polynomial
        prev=FGB(creat_poly)(k); // k is the number of monomials in the polynomial
        input_basis[m++]=prev;/* fill the array of input polynomials with the first polynomial */
        for(int i=0;i<k;i++){
            I32 e[3];
            // copy the data of the monom into an array
            for(int l=0;l<3;l++){
                e[l] = P.monoms[i][l];
            }
            FGB(set_expos2)(prev,i,e,nb_vars); //arguments -prev: the reference polynom -i, the i-th monom -e the monom's powers
            FGB(set_coeff_I32)(prev,i,1);
        }
        FGB(full_sort_poly2)(prev); /* it is recommended to sort each polynomial */
    }
    
    /* Computing the GB*/
    int nb;
    const int n_input=5; /* we have 5 polynomials on input */
    SFGB_Options options;

    /* set default options (by default we compute a GB) */
    FGb_set_default_options(&options);

    /* overide some default parameters */
    options._env._force_elim=0; /* if force_elim=1 then return only the result of the elimination
				    (need to define a monomial ordering DRL(k1,k2) with k2>0 ) */
    options._env._index=500000; /* This is is the maximal size of the matrices generated by F4
				    you can increase this value according to your memory */

    options._verb=1; /* display useful infos during the computation */

    /* Other parameters :
       t0 is the CPU time (reference to a double)
    */
    nb=FGB(fgb)(input_basis,n_input,output_basis,FGb_MAXI_BASE,&t0,&options);
    /* The value nb returned by the library is the number of polynomials */



    int i;
	fprintf(stderr,"[\n");
	for(i=0;i<nb;i++)
	  {
	    /* Import the internal representation of each polynomial computed by FGb */
	    {
	      const I32 nb_mons=FGB(nb_terms)(output_basis[i]); /* Number of Monomials */
	      I32* Mons=(I32*)(malloc(sizeof(UI32)*nb_vars*nb_mons));
	      I32* Cfs=(I32*)(malloc(sizeof(I32)*nb_mons));
	      int code=FGB(export_poly)(nb_vars,nb_mons,Mons,Cfs,output_basis[i]);
	      I32 j;
	      for(j=0;j<nb_mons;j++)
		{

		  I32 k,is_one=1;
		  I32* ei=Mons+j*nb_vars;

		  if (j>0) fprintf(stderr,"+");
		  fprintf(stderr,"%d",Cfs[j]);

		  for(k=0;k<nb_vars;k++)
		    if (ei[k])
		      {
			if (ei[k] == 1)
			  fprintf(stderr,"*%s",vars[k]);
			else
			  fprintf(stderr,"*%s^%u",vars[k],ei[k]);
			is_one=0;
		      }
		  if (is_one)
		    fprintf(stderr,"*1");
		}
	      free(Cfs);
	      free(Mons);
	    }


	    if (i<(nb-1))
	      fprintf(stderr,",");

	  }
	fprintf(stderr,"]\n");

  
  FGB(reset_memory)(); /* to reset Memory */
  FGB(restoreptr)(); /* restore original GMP allocators */
  return I;
}



int main(){
    vector<int> pentagon1 {1,1,1,1,1};
    vector<vector<int>> pentagon1_indexed = index_pentagon(pentagon1);
    vector<vector<int>> max_faces = find_max_faces(pentagon1_indexed);
    vector<vector<int>> min_non_faces = find_min_non_faces(pentagon1_indexed);
    vector<vector<vector<int>>> list_lambdas = compute_chr_funct(pentagon1);
    vector<Z2_polynom> I = find_polynoms(list_lambdas[0],max_faces,min_non_faces,pentagon1_indexed);
    cout<<I.size()<<'\n';
    for(auto P:I){
        cout<<"new"<<'\n';
        P.display_monoms();
    }
    vector<Z2_polynom> U = compute_GB(I);
    }







